<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Iron Turtle - Test Fixes</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
</head>
<body>
    <div class="container mt-5">
        <h1>Iron Turtle - Testing Critical Fixes</h1>
        
        <div class="card mt-4">
            <div class="card-header">
                <h3>Test Results</h3>
            </div>
            <div class="card-body">
                <div id="test-results"></div>
            </div>
        </div>
    </div>

    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/9.0.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.0.0/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.0.0/firebase-firestore-compat.js"></script>
    
    <script src="js/firebase-config.js"></script>
    <script src="js/activities.js"></script>
    <script src="js/data-utils.js"></script>
    <script src="js/scoring.js"></script>
    
    <script>
        // Test suite for critical fixes
        class TestSuite {
            constructor() {
                this.results = [];
                this.runTests();
            }
            
            log(testName, passed, message) {
                this.results.push({ testName, passed, message });
                const resultsDiv = document.getElementById('test-results');
                const resultDiv = document.createElement('div');
                resultDiv.className = `alert ${passed ? 'alert-success' : 'alert-danger'} mt-2`;
                resultDiv.innerHTML = `
                    <strong>${testName}:</strong> ${passed ? '✅ PASSED' : '❌ FAILED'}
                    <br><small>${message}</small>
                `;
                resultsDiv.appendChild(resultDiv);
            }
            
            async runTests() {
                // Test 1: Points Validation
                this.testPointsValidation();
                
                // Test 2: Data Structure Standardization
                this.testDataStandardization();
                
                // Test 3: Multiplier Logic Consistency
                this.testMultiplierLogic();
                
                // Test 4: Transaction Handling (mock test)
                this.testTransactionConcepts();
                
                // Test 5: Cascade Deletion Logic
                this.testCascadeDeletion();
            }
            
            testPointsValidation() {
                const testCases = [
                    { input: NaN, expected: 0, desc: 'NaN should return 0' },
                    { input: Infinity, expected: 10000, desc: 'Infinity should be clamped to max' },
                    { input: -Infinity, expected: -100, desc: '-Infinity should be clamped to min' },
                    { input: 999999, expected: 10000, desc: 'Large numbers should be clamped' },
                    { input: -999999, expected: -100, desc: 'Large negative should be clamped' },
                    { input: 3.7, expected: 4, desc: 'Decimals should be rounded' },
                    { input: 3.3, expected: 3, desc: 'Decimals should be rounded down' }
                ];
                
                let allPassed = true;
                let failedTests = [];
                
                testCases.forEach(test => {
                    const result = DataUtils.validatePoints(test.input);
                    if (result !== test.expected) {
                        allPassed = false;
                        failedTests.push(`${test.desc}: got ${result}, expected ${test.expected}`);
                    }
                });
                
                this.log(
                    'Points Validation',
                    allPassed,
                    allPassed ? 'All edge cases handled correctly' : `Failed: ${failedTests.join('; ')}`
                );
            }
            
            testDataStandardization() {
                const rawActivity = {
                    userId: 'user123',
                    activityName: 'Test Activity',
                    points: 'invalid',
                    multipliers: 'not-an-array',
                    extraField: 'should-be-removed'
                };
                
                const standardized = DataUtils.standardizeActivityData(rawActivity);
                
                const checks = [
                    standardized.hasOwnProperty('userId'),
                    standardized.hasOwnProperty('userName'),
                    standardized.hasOwnProperty('activityName'),
                    Array.isArray(standardized.multipliers),
                    typeof standardized.points === 'number',
                    !standardized.hasOwnProperty('extraField'),
                    standardized.quantity === 1 // Default value
                ];
                
                const allPassed = checks.every(check => check === true);
                
                this.log(
                    'Data Structure Standardization',
                    allPassed,
                    allPassed ? 'Data properly standardized with defaults' : 'Standardization failed'
                );
            }
            
            testMultiplierLogic() {
                // Get sample activities and multipliers
                const drinkActivity = { category: 'consumables', id: 'drink_test' };
                const taskActivity = { category: 'tasks', id: 'task_test' };
                const penaltyActivity = { category: 'penalties', id: 'penalty_test' };
                
                // Find actual multipliers from the data
                const drinkMultiplier = window.MULTIPLIERS?.find(m => m.appliesToConsumables && !m.appliesToOthers);
                const generalMultiplier = window.MULTIPLIERS?.find(m => m.appliesToOthers && !m.appliesToConsumables);
                const bothMultiplier = window.MULTIPLIERS?.find(m => m.appliesToConsumables && m.appliesToOthers);
                
                if (!drinkMultiplier || !generalMultiplier) {
                    this.log('Multiplier Logic Consistency', false, 'Required multipliers not found in data');
                    return;
                }
                
                const tests = [
                    {
                        activity: drinkActivity,
                        multiplier: drinkMultiplier,
                        shouldApply: true,
                        desc: 'Drink multiplier should apply to drinks'
                    },
                    {
                        activity: drinkActivity,
                        multiplier: generalMultiplier,
                        shouldApply: false,
                        desc: 'General multiplier should NOT apply to drinks'
                    },
                    {
                        activity: taskActivity,
                        multiplier: drinkMultiplier,
                        shouldApply: false,
                        desc: 'Drink multiplier should NOT apply to tasks'
                    },
                    {
                        activity: taskActivity,
                        multiplier: generalMultiplier,
                        shouldApply: true,
                        desc: 'General multiplier should apply to tasks'
                    }
                ];
                
                let allPassed = true;
                let failedTests = [];
                
                tests.forEach(test => {
                    const result = DataUtils.canApplyMultiplier(test.activity, test.multiplier);
                    if (result !== test.shouldApply) {
                        allPassed = false;
                        failedTests.push(test.desc);
                    }
                });
                
                this.log(
                    'Multiplier Logic Consistency',
                    allPassed,
                    allPassed ? 'Multipliers apply consistently across categories' : `Failed: ${failedTests.join('; ')}`
                );
            }
            
            testTransactionConcepts() {
                // Test that transaction-related code doesn't throw errors
                try {
                    // Test points calculation with various options
                    const activity = { 
                        id: 'test', 
                        category: 'competition', 
                        winPoints: 10, 
                        lossPoints: -5 
                    };
                    
                    const winPoints = DataUtils.calculatePoints(activity, [], 1, { competitionResult: 'win' });
                    const lossPoints = DataUtils.calculatePoints(activity, [], 1, { competitionResult: 'loss' });
                    
                    const passed = winPoints === 10 && lossPoints === -5;
                    
                    this.log(
                        'Transaction Concepts',
                        passed,
                        passed ? 'Competition points calculated correctly' : `Win: ${winPoints}, Loss: ${lossPoints}`
                    );
                } catch (error) {
                    this.log('Transaction Concepts', false, `Error: ${error.message}`);
                }
            }
            
            testCascadeDeletion() {
                // Test the scoring engine's deletion logic
                const scoringEngine = window.scoringEngine;
                
                if (!scoringEngine) {
                    this.log('Cascade Deletion Logic', false, 'Scoring engine not available');
                    return;
                }
                
                // Save current state
                const originalActivities = [...scoringEngine.activities];
                const originalCompleted = [...scoringEngine.completedOneTimeTasks];
                
                // Add test data
                const testUserId = 'test_user_' + Date.now();
                const testActivityId = 'one_time_test_' + Date.now();
                
                // Simulate a one-time task
                scoringEngine.activities.push({
                    id: 1001,
                    userId: testUserId,
                    activityId: testActivityId,
                    points: 10
                });
                
                scoringEngine.completedOneTimeTasks.push(testActivityId);
                
                // Test deletion
                scoringEngine.removeActivity(1001);
                
                // Check if activity was removed
                const activityRemoved = !scoringEngine.activities.find(a => a.id === 1001);
                
                // Check if completed task was unmarked (since no other instances exist)
                const taskUnmarked = !scoringEngine.completedOneTimeTasks.includes(testActivityId);
                
                // Restore original state
                scoringEngine.activities = originalActivities;
                scoringEngine.completedOneTimeTasks = originalCompleted;
                
                const passed = activityRemoved && taskUnmarked;
                
                this.log(
                    'Cascade Deletion Logic',
                    passed,
                    passed ? 'One-time tasks properly unmarked on deletion' : 'Cascade deletion failed'
                );
            }
        }
        
        // Run tests when page loads
        window.addEventListener('load', () => {
            new TestSuite();
        });
    </script>
</body>
</html>